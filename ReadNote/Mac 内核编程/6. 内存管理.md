# 内存管理 

## 引言 
内核中的内存管理要比用户空间程序的内存管理复杂的多。   
用户空间程序通常处理平面线形地址空间， 可以分配任意块内存，无须关注该内存的来源或布局。  

内核必须处理多个内存空间， 其中包括自有的内存空间以及这些内存空间与物理内存之间的映射关系。  
内核常常需要知道内存是否联系及其分布位置。__因为一些硬件设备无法读取某些内存地址，或对内存对其有特定需求__  例如： 只能读取16字节边界对其的内存或无法读取地址高于32位的内存   

__内核内存管理最明显的挑战是如何尽可能少用内存__, 



## 1. 内存类型  
内存类型分为： 
* CPU物理地址  
* 总线物理地址  
* 用户和内核虚拟地址  

> 不同体系结构之间可寻址的内存数量也各不相同， 可以从32 位到 64位， 内存还会根据体系结构进行不同的排序， 可以是小端序或大端序   


### 1. CPU 物理地址  
__物理地址__: 指CPU为访问物理内存而使用的寻址系统。物理地址隐藏在CPU 的 MMU之后。 空间呈线形；对物理内存的访问会缓存在较小的内存 缓冲器中，(L1, L2), 一般包含在CPU核心中。    
__MMU__: 内存管理单元， 会将内核和用户空间常用的虚拟地址转换为物理地址  


__通常无须直接处理物理地址，即使是编写驱动程序也无需如此__  


### 2. 总线物理地址  
>  传 统 的 I / 0 总 线 ( 如 P C I 和 P C I X ) 无 法 访 问 3 2 位 以 上的内存地址
实际上是，经过 `DART` 转换后的虚拟地址   
在 `I/O Kit`使用时，使用`IOMemoryDescriptor`时， 会自动执行所需转换  
驱动程序可以使用`IOPhysicalAddress`类型处理物理地址， 该类型的长度取决于底层体系结构。   

__I/O MMU__： I/O内存管理单元，是面向直接 I/O (VT-d) 的虚拟化技术之一   



### 3. 用户和内核虚拟地址  
虚拟地址呈线性，通过CPU上 一个名为内存管理单元(MMU)的特殊芯片转换为物理地址   
每个用户空间进程都有自己的内存地址空间，从各方面看就像一个进程拥有所有的物理内存   
用 户空间进程可以使用其地址空间中任意的内存位置，即使地址位置超出了物理内存数量    
对 一个 进程来说，虚拟地址空间看起来呈线性，尽管支撑它的内存可能是碎片。  

Macos x对内核(4GB)和用户空间进程(4GB)使用了完全独立的 地址空间，但正如前文所说，__其缺点是上下文切换代价较高__  
高128 T字节预留给内核，而低128 T字节则属于当前运行的用户空间任务
__该地址空间与用户空间共享， 但因为页保护标识，任务不能访问内核内存。__  

__分页器__: 用于获取包含给定内存地址的页, 如果页不存在，那么就会发生`缺页异常`  

__进程不可以访问虚拟地址空间的第一页(0~4KB)，如果试图访问，将会发生异常。__  



与体系结构无关的类型`IOVirtualAddress`可用于处理 I/O Kit 代码中的虛拟地址。该类型又是
`mach_vm_address_t` 的别名，是Mach 层中用于虚拟内存地址的类型。   


 #### 4.  内存顺序： 大端序和小端序  
 字节序： 是内存中二进制字的组成顺序  

 ```c++ 
 int main(int argc, char *argv[]) {
    uint32_t word = 0xaabbccdd;
    uint8_t* ptr = (uint8_t*)&word;
    printf("%02x %02x %02x %02x\n", ptr[0], ptr[1], ptr[2], ptr[3]);
    return 0;
} 
 ```
 > 验证内存顺序： 结果为 `dd cc bb aa`是小端序； `aa bb cc dd`: 为大端序  


* 小端序： 
    系统上的顺序为逆向  
    所有的Mac都是小端序，`x86/arm`都是小端序架构  

* 大端序： 
    部分硬件体系结构或网络协议(如TCP/IP)使用的是大端序  

__编译器定义了`__LITTLE_ENDIAN` 和 `__BIG_ENDIAN__`宏， 用来确定编译时的字节顺序  




#### 5. 32 位和 64 位内存寻址  



## 2. 内存分配  
内核内存分配设备的范围从类似于用户空间`malloc()`接口的高层机制到对原始页的直接分配   
获得内存的不同函数有许多个，具体采用哪一个取决于你使用的子系统，例如`Mach`、`BSD`或`I/O Kit`，以及对内存的需求，如`大小`或`对齐`。   

__在最底层，内核使用`vm_page`结构体记录物理内存, 每个 vmpage 结构体都对应一个物理内存页__   

* `活动链表(Active List)`:  包 含 映 射 到 至 少 一个 虚 拟 地 址 空 间 的 物 理 内 存 页 ， 并 且 最 近 使 用过。
* `惰性链表(inactive List)`: 包含已分配但最近未使用的页。
* `空闲链表(free list)`:  包 含 未 分 配 的 页 。
 
> 要从空闲链表取得一个空闲页，可以使用`vm_page_gzab()`两数或其高层接又 `vm_page_al1oc()`，不同于`vm_page_Brab()`函数，`vm_page_alloc()`是将页放置到`vm_object` 对象中，而不是将其从空闲链表中移除。如果内核检测到空闲页的等级低于阀值，则将通知分页守护进程 。 在 这 种 情 况 下 ， 分 页 器 将 根 据 最 近 最 少 使 用 (`LRU`) 原 则 ， 从惰性链表逐出页  __磁盘文件映射的页是主要的驱逐对象，可以轻易地丢弃__ , __VM页缀存和文件系统缓存组合在一起，可以避免复制，统称为统一绥冲区缓存__  


### 底层分配机制  
内核有多个内存分配例程族。 VM 子系统位 于内核的Mach部分， 实现内存分配的底层接口。   
内核的Mach部分执行操作，需要使用`kmem_alloc*()`的数族.   

所有的两数都需要指定一个属于用户空间任务或kernel_map的VM映射。上面的所有函数都分配联动内存，这些内存无法换出，但`kmern_alloc_pageable()`除外。  
![图 0](images/47b09d216a5d033a4e16128c63bc007b7b310852015abbd3d2d1f18a03de472c.png)  

### Mach 内存域分配器  
Mach内存城分配器是 一种分配机制， 可以分配名为内存域的固定长度的内存块。 
`内存域`： 通常表示一个广泛使用的内核数据结构，如文件描述符或任务描述符，但也可以指向更为通用的内存块   
内存域分配器分配的数据结构示例包括：  
* 文件描述符  
* BSD套接字 
* 任务(struct task); 
* 虚拟内存结构(VM 映射， VM 对象 )  


#### 自定义内存域 
如果需要频繁、快速地分配和释放相同类型的数据对象， 可以使用`zinit()` 函数创建自己的内存域。 为了创建 一个新的内存域，你需要告诉分配器对象的大小、队列的最大 长度及分配大小，这会指定内存城耗尽时需要添加的内存量。 



### kalloc 家族  
kalloc 家族为快速分配内 存 提 供 了一 个 略 高 级 的 接 口 。   
V0 Kit和BSD层的底层内存函数基于kalloc 家族 提 供 的 A P I 进 行 构 建。  k a 1 1 o c 两 数 还 为C + + 的 内 存 分配 操 作 符 `n e w`和`n e w [ ]`提 供 内 存。   
除 k a l l o c _ n o b l o c k ( ) 外 、 k a l l o c 関 数 及 其 変 体 可 以 阻塞 (睡 眠 ) 以 得 内 存 
![图 1](images/d4d28463cf459664fd8e5a870f34341cf98bb6fd38f8adc5f6928168b863cd9f.png)  


### BSD 中的内存分配 
![图 2](images/faadf5f04d782429c45951cab18b7c44c8be0845087ea74798de858ef6f42ccb.png)  




