# 动态调试  
> 将程序运行起来，通过下断点、打印的方式，查看参数，返回值，函数调用流程等   


## Xcode 动态调试原理  
* 关于 GCC、LLVM、GDB、LLDB  
    * Xcode 编译器发展史： GCC----> LLVM
    * Xcode 调试器发展史： GDB -----> LLDB  


### debugserver
* debugserver一开始存放在Mac的Xcode 中  
    `Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/9.1/DeveloperDiskImage.dmg/usr/bin/debugserve`  
* 当Xcode 识别到手机设备，会自动将debugserver 安装到iPhone中  
    `Developer/usr/bin/debugserver`  
* Xcode 调试的局限性  
    一般情况下，只能调试通过Xcode 安装的App  

## 动态调试任意APP  
> debugserve 连接到 对应APP ， 然后 LLDB 连接到 debugserver  

* debugserver 权限问题  
    默认情况下，缺少一定的权限，只能调试通过xcode 安装的APP， 无法调试其他APP  
    如果希望调试其他APP，需要重新签名，添加一下两个权限  
    * `get-task-allow` 
    * `task_for_pid-allow`

* 重新签权限  
    * 复制iPhone 中的 debugserver 文件到Mac  
    * 通过ldid 导出权限 
        `ldid -e debugserver > debugserver.entitlements` 
    * 添加权限 
        编辑entitlements 文件，添加以上两个属性，设置值为 true  
    * 重新签名   
    * 添加到iPhone
        由于原始目录的时只读的，所以不能复制，可以将其放到 `usr/bin`目录下     


### debugserver 环境搭建  
1. 重新签名debugserver  
2. 开启监听  
    `debugserver *:10011 -a WeChat`  
3. lldb 连接  
    * 启动lldb  
        `lldb` 
    * 连接到debugserver  
        * 通过IP进行连接  
            `process connect connect://手机IP:debugserver服务端口号(此处为10011)`    
        * 通过端口映射连接  
            * 更改脚本，添加映射端口 
                `python ~/xxx/tcprelay.py -t 22:10010 10011:10011` 
            * 连接  
                `process connect connect://localhost:10011`   
    * 使用 LLDB 命令让程序继续运行  
        `c`  
__扩展__：   
    可以通过debugserver 启动APP  
    `debugserver -x auto *:端口号 App 可执行文件路径`   




## LLDB 指令  
#### 命令格式  
`<command> [<subcommand>] <action> [-options] [argument]`  
* `<command>`: 命令  
* `<subcommand>`:子命令
* `<action>`:命令操作
* `<option>`:命令选项
* `<arguments>`:命令参数

### 常用指令
#### Expression  
执行一个表达式  
`expression self.view.backgroundColor = [UIColor redColor];` 
* expression、expression -- 和指令 print 、p、call 效果一样  
* expression -O -- 和指令 po 效果一样  

#### thread 
* backtrace 
    * 打印线程的堆栈信息  
    * 和指令 `bt` 效果一样  
* return  
    * 让函数直接返回某个值，不会执行断点后面的值 
* continue,`c`
    程序继续执行
* step-over (next = `n`)
    单步运行，把子函数当做整体，一步执行  
* step-in,step,`s` 
    单步运行，遇到子函数，会进入函数内部  
* step-out,finish 
    直接执行完当前函数的所有diamante，返回上一个函数  

```
// instruction level 指令级别的单步运行(汇编指令)
thread step-inst-over = nexti = ni 
thread step-inst = stepi = si 

// source level 源码级别的单步运行
thread step-over = next  = n 
thread step-in = step = s 



```




#### breakpoint 
* set 
    设置断点 `breakpoint set -a 函数地址`  
* 


#### frame variable [<variable-name>] 
* 打印当前栈帧的变量   






## ASLR  
### 概念简介 
* VM address： 虚拟内存地址  
* VM Size: 内存大小，查勇多少内存  
* File Offset:在 Mach-O 文件中的位置  
* File Size: 在Mach-o 文件中占据大小  

* 函数代码存放在 `__TEXT`段中   

* ASLR: 使得内存地址分布随机化， 使Mach-O 起始地址发生变化，偏移  

### 获取系统随机偏移量  
`image list -o -f | grep 应用名称`  此时打印的地址就是的  


