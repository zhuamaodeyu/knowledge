## 重签名调试  


#### 检测debug 状态    
可以通过此种方式检测， 如果当前APP处于debug状态， 那么久直接杀死系统   

```
#import <sys/sysctl.h>
BOOL isDebugger() {
	int name[4];   // 存放字节码  
	name[0] = CTL_KERN； // 内核查询
	name[1] = KERN_PROC; // 查询进程  
	name[2] = KERN_PROC_PID; // 传递的参数是进程ID 
	name[3] = getpid();	// PID 进程ID  
	
	struct kinfo_proc info;
	size_t info_size = sizeof(info);
	sysctl(name, sizeof(name)/sizeof(*name), &info, &info_size, 0, 0);
	
	// 结果再info中  
	if(info.kp_proc.p_flag  & P_TRACED) != 0 {
		return true; 
	}
	return false ;
}
```

#### 破解以上的限制  
1. 添加 exit 断点  
2. 执行后断点到 `libsystem_c.dylib` 此处会断点  
3. 获取偏移地址     

	```
	image list 	//获取镜像列表  
	
	系统函数地址 - 镜像首地址 = 偏移地址
	
	```
4. 创建cocoa touch framework 
	添加  `fishhook`   
	创建一个类  
	
	```
	#Import "fishhook.h" 
	#import <sys/sysctl.h>  
	
	int(* sysctl_p)(int *, u_int, void *, size_t, void * , size_t);
	
	int mySysctl(int *name, u_int nameLen, void * info, size_t *infosize, void *newInfo, size_t newInfosize) { 
		if (namelen == 4 && name[0] ==CTL_KERN && name[1]........) {
			// 调用系统的  
			int err =  sysctl_p(name, nameLen, info, infosize, newInfo, newInfosize); 
			// 拿到info
			struct kinfo_proc * myinfo = info;
			
			if ((myinfo -> kp_proc.p_flag & P_TRACED) != 0) {
				  // 使用异或可以取反  
				  myinfo->kp_proc.p_flag ^= P_TRACED;
			}
		}

		return sysctl_p(name, nameLen, info, infosize, newInfo, newInfosize);
	}
	
	+(load) {
		struct rebinding ptracebd; 
		ptracebd.name = ""; // hook 函数名称
		ptracebd.replacement = ;//  hook的函数地址  
		ptracebd.replaced = (void *)&ptrace_p;	//原始函数地址保存
		
		//rebind_symbols((struct rebinding[1]{{ "sysctl",mySysctl, &sysctl_p}}, 1);
	}
	```

### 动态调试原理  
1. 进程附加技术  
	`ptrace`   
	```
	arg0: ptrace 要做的事  
	arg2: 要做的事  
	
	ptrace(PT_DENY_ATTACH, 0,0,0)
	```
	通过xcode运行， 默认启动了 debugServer,但用户是可以正常使用的   

	> 使用方式： 直接监听 `runloop`, 直接休眠，就执行此代码   
	* 破解方式：  直接使用 hishhook 进行hook   
2. 避免被hook， 拿到动态库的地址  
	```
	void * handle = dlopen("/usr/lib/system/libsystem_kernel.dylib",RTLD_LAZY)
	 // 直接获取函数指针  
	 ptrace_p = dlsym(handle, "ptrace"); 
	 if(ptrace_p) {
	 	ptrace_p(PT_DENY_ATTACH,0,0,0)
	 }
	 
	```
	通过此种方式，无法进行hook  
	
	
	

> 可变参数要想重写hook， 需要用到 汇编， 需要寄存器中拿参数   
> obj_msgSend, 不能进行swift ， C, block  
> Clang 进行插桩   




### 总结  
1. 非越狱注入  
	* 重签名   

2. 代码混淆  
	可以防止静态分析，但是无法防止动态调试  
3. 检测mach-O文件的更改
4. 检测 c_load_lib, 给白名单    
	
	```
	// 注意，主二进制是沙盒是会变的。  
	// 不同的架构，不同的系统下，应该是不同的白名单   
	int count = _dyld_image_count(); 
	for(int i = 0; i < 0; i++) {
		// 此处可以是一个数组， 保存所有的库，然后进行判断， 
		// 是一个字符串，然后判断当前name是否是这个字符串的子路径  
		// strstr(全string， substring)
		const char*name = _dyld_get_image_name(i); 
		
	}
	```

5. 动态库的插入  
__越狱环境下，恶意代码是通过修改 `DYLD_INSERT_LIBRARIES`  环境变量达到注入的效果__   
	```
	源码 5692 行  
	// 此条件为真，就移除动态添加的插入
	if(gLinkContext.processIsRestricted) {
		pruneEnvronmentVariables(envp, &apple);
	}
	```
	环境编译   
	
	```
	Other Linker Flags  
	
		-Wl ,-sectcreate, __RESTRICT, __restrict,/dev/null
	
	```
	
	破解： 直接修改 Mach-O文件中这个字段的值   

6. 判断   
	
	```
	复制 hasRestrictedSegment 方法到项目中，然后判断     
	
	
	const struct mach_header_64 * header = _dyld_get_image_header(0);  // 获取主image的头信息  
	if (hasRestrictedSegment(header)) {
		// 防护有效 
	}else {
		// 被修改了   
		// 此处可以进行一些判断，做一些补偿措施 ，例如给服务器发送对应代码，进行账号封禁  
		
	}
	
	```





