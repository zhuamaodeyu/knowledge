

### 1. LayoutManager / Storage / Container å…³ç³»
1. Storage `<--add--` LayoutManager
2. LayoutManager `<-----add-----` NSTextContainer  
3. UITextView `<-----add -----`  NSTextContainer

```objective-c
    NSTextStorage *sharedTextStorage = self.originalTextView.textStorage; 
    NSLayoutManager *otherLayoutManager = [NSLayoutManager new];
    [sharedTextStorage addLayoutManager: otherLayoutManager];
    
    NSTextContainer *otherTextContainer = [NSTextContainer new];
    [otherLayoutManager addTextContainer: otherTextContainer];
    
    UITextView *otherTextView = [[UITextView alloc] initWithFrame:self.otherContainerView.bounds textContainer:otherTextContainer];

```

__æ¯ä¸€ä¸ª NSTextStorage å¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ª NSLayoutManager ï¼Œæ¯ä¸ª NSLayoutManager ä¹Ÿå¯ä»¥åŒ…å«ä¸€ä¸ªæˆ–è€…å¤šä¸ª NSTextContainer ã€‚__

### 2. å¤šä¸ª NSTextContainer å…±å­˜çš„é—®é¢˜ (åŒä¸€ä¸ª Storage ï¼Œ åŒä¸€ä¸ª LayoutManager ) 

```swift
// Container 1
let firstTextContainer = NSTextContainer()
firstTextContainer.widthTracksTextView = true
firstTextContainer.heightTracksTextView = true

// Container 2
let secondTextContainer = NSTextContainer()
secondTextContainer.widthTracksTextView = true
secondTextContainer.heightTracksTextView = true
secondTextContainer.lineBreakMode = .byTruncatingTail

let layoutManager = NSLayoutManager()
layoutManager.addTextContainer(firstTextContainer)
layoutManager.addTextContainer(secondTextContainer)

textStorage.addLayoutManager(layoutManager)

//è¿™é‡Œå¯ä»¥ä¸ä½¿ç”¨å¤šä¸ª UITextView 
let firstTextView = UITextView(frame: .zero, textContainer: firstTextContainer)
firstTextView.isScrollEnabled = false       // æ³¨æ„ï¼Œç¬¬ä¸€ä¸ªè®¾ç½®å¯æ»šåŠ¨ï¼Œç¬¬äºŒä¸ªå°±æ— æ•ˆäº†ï¼Œæ— æ³•æ˜¾ç¤ºå†…å®¹äº†
view.addSubview(firstTextView)

let secondTextView = UITextView(frame: .zero, textContainer: secondTextContainer)
secondTextView.isScrollEnabled = false
view.addSubview(secondTextView)

```

__é‡ç‚¹ï¼š__ å¦‚æœç¬¬ä¸€ä¸ª  UITextView ä¸èƒ½æ»šåŠ¨ï¼ŒscrollEnabled = false, åˆ™å†…å®¹ä¼šå¡«å……å®Œç¬¬ä¸€ä¸ªï¼Œå†æ¥ç€å¡«å……ç¬¬äºŒä¸ªã€‚å¦‚æœç¬¬ä¸€ä¸ªå¯æ»šåŠ¨ï¼Œåˆ™ä¸ä¼šå¡«å……ç¬¬äºŒä¸ªã€‚




### è¯­æ³•çªå‡ºæ˜¾ç¤º  
è‡ªå®šä¹‰ `NSTextStorage` åœ¨ processEditing æ–¹æ³•ä¸­è¿›è¡Œæ­£åˆ™åŒ¹é… addAttribute å±æ€§ 

```objective-c
- (void)processEditing
{
    // æ­£åˆ™è¡¨è¾¾å¼
    static NSRegularExpression *iExpression;
    iExpression = iExpression ?: [NSRegularExpression regularExpressionWithPattern:@"i[\\p{Alphabetic}&&\\p{Uppercase}][\\p{Alphabetic}]+" options:0 error:NULL];
    
    
    // æ¸…æ¥šå·²æœ‰çš„é¢œè‰²å±æ€§ç­‰
    NSRange paragaphRange = [self.string paragraphRangeForRange: self.editedRange];
    [self removeAttribute:NSForegroundColorAttributeName range:paragaphRange];
    
    // æ­£åˆ™åŒ¹é…
    [iExpression enumerateMatchesInString:self.string options:0 range:paragaphRange usingBlock:^(NSTextCheckingResult *result, NSMatchingFlags flags, BOOL *stop) {
        // Add red highlight color
        [self addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:result.range];
    }];
  
  
  [super processEditing];
}



```  


### è®¾ç½®é€‰ä¸­åŒºåŸŸè§’æ ‡ 
```

// å¦‚æœæ²¡æœ‰é€‰ä¸­ï¼Œç›´æ¥è¿”å›
NSRange selectedRange = self.textView.selectedRange;
if (!selectedRange.length) {
    self.clippyView.hidden = YES;
    return;
}
// æŸ¥æ‰¾æ‰€é€‰å†…å®¹çš„æœ€åä¸€ä¸ªçŸ©å½¢
NSRange glyphRange = [self.textView.layoutManager glyphRangeForCharacterRange:selectedRange actualCharacterRange:NULL];
__block CGRect lastRect;
[self.textView.layoutManager enumerateEnclosingRectsForGlyphRange:glyphRange withinSelectedGlyphRange:glyphRange inTextContainer:self.textView.textContainer usingBlock:^(CGRect rect, BOOL *stop) {
    lastRect = rect;
}];


// å°†è§’æ ‡å›¾æ ‡æ”¾åœ¨æ‰€é€‰å†…å®¹çš„å³ä¸‹è§’
CGPoint clippyCenter;
clippyCenter.x = CGRectGetMaxX(lastRect) + self.textView.textContainerInset.left;
clippyCenter.y = CGRectGetMaxY(lastRect) + self.textView.textContainerInset.top;

clippyCenter = [self.textView convertPoint:clippyCenter toView:self.view];
clippyCenter.x += self.clippyView.bounds.size.width / 2;
clippyCenter.y += self.clippyView.bounds.size.height / 2;

self.clippyView.hidden = NO;
self.clippyView.center = clippyCenter;

```


### è®¾ç½® ExclusionPaths 

```objective-c
- (void)updateExclusionPaths
{

    CGRect ovalFrame = [self.textView convertRect:self.circleView.bounds fromView:self.circleView];
    
    // Since text container does not know about the inset, we must shift the frame to container coordinates
    // ç”±äºæ–‡æœ¬å®¹å™¨ä¸çŸ¥é“æ’å›¾ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å°†æ¡†æ¶ç§»åŠ¨åˆ°å®¹å™¨åæ ‡
    ovalFrame.origin.x -= self.textView.textContainerInset.left;
    ovalFrame.origin.y -= self.textView.textContainerInset.top;
    
    // Simply set the exclusion path
    // è®¾ç½®æ’é™¤è·¯å¾„
    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect: ovalFrame];
    self.textView.textContainer.exclusionPaths = @[ovalPath];
    
    // And don't forget clippy
    // [self updateClippy];
}


```

```swift 


    /**
     é®ç›–èŒƒå›´
     */
    private func _updateExclusionPaths() {
        var circleFrame = self.textView.convertRect(timeIndicatorView.bounds, fromView: timeIndicatorView) // åæ ‡è½¬æ¢
        circleFrame.origin.x = circleFrame.origin.x - textView.textContainerInset.left
        circleFrame.origin.y = circleFrame.origin.y - textView.textContainerInset.top
        let circlePath = UIBezierPath(roundedRect: circleFrame, cornerRadius: timeIndicatorView.radius())
        textView.textContainer.exclusionPaths = [circlePath]
    }

```

```swift 
// æ‰‹åŠ¿äº‹ä»¶
@IBAction func imagePanned(_ sender: Any) {
    guard let pan = sender as? UIPanGestureRecognizer else { return }
    switch pan.state {
    case .began:
        panInitialImageCenter = imageView.center
    case .changed:
        let panCurrentTranslation = pan.translation(in: textView)
        imageView.center = CGPoint(x: panInitialImageCenter.x + panCurrentTranslation.x,
                                    y: panInitialImageCenter.y + panCurrentTranslation.y)
        textView.textContainer.exclusionPaths = [translatedCirclePath]
    default: return
    }
}


```



### è‡ªå®šä¹‰ è¡Œé«˜ 

```swift 


func layoutManager(_ layoutManager: NSLayoutManager, shouldSetLineFragmentRect lineFragmentRect: UnsafeMutablePointer<NSRect>, lineFragmentUsedRect: UnsafeMutablePointer<NSRect>, baselineOffset: UnsafeMutablePointer<CGFloat>, in textContainer: NSTextContainer, forGlyphRange glyphRange: NSRange) -> Bool {
    
    let lineHeightMultiple: CGFloat = 1.6
    let font: NSFont = NSFont.systemFont(ofSize: NSFont.systemFontSize)
    let fontLineHeight = layoutManager.defaultLineHeight(for: font)
    let lineHeight = fontLineHeight * lineHeightMultiple
    let baselineNudge = (lineHeight - fontLineHeight)
        // The following factor is a result of experimentation:
        * 0.6

    var rect = lineFragmentRect.pointee
    rect.size.height = lineHeight

    var usedRect = lineFragmentUsedRect.pointee
    usedRect.size.height = max(lineHeight, usedRect.size.height) // keep emoji sizes

    lineFragmentRect.pointee = rect
    lineFragmentUsedRect.pointee = usedRect
    baselineOffset.pointee = baselineOffset.pointee + baselineNudge

    return true
}


```




## è‡ªå®šä¹‰ å½¢çŠ¶æ–‡æœ¬å®¹å™¨ 
åœ¨å¸ƒç½®ä¸€è¡Œæ–‡æœ¬æ—¶ï¼ŒTextKit è°ƒç”¨è¯¥ ` lineFragmentRect(forProposedRect:at:writingDirection:remaining:) ` æ–¹æ³•ï¼Œç”¨äºç¡®å®šè¡Œçš„ä½ç½®å’Œå¤§å°ï¼ŒTextKit è°ƒç”¨è¡Œç‰‡æ®µçŸ©å½¢
æ­¤ç¤ºä¾‹ä½¿ç”¨ CircleTextContainer ç±»æ¥å®ç°å¾ªç¯æ–‡æœ¬å®¹å™¨ã€‚ä¸ºäº†è®¡ç®—é€‚åˆå®¹å™¨è¾¹ç•Œçš„å†…åµŒåœ†åœˆçš„çº¿ç‰‡æ®µçŸ©å½¢ï¼Œè¯¥ç±»è°ƒç”¨ super çš„å®ç°æ¥æ£€ç´¢é»˜è®¤çŸ©å½¢ï¼Œç„¶åæ ¹æ®å½“å‰çº¿åŸç‚¹å’Œå®¹å™¨å¤§å°è°ƒæ•´å…¶ source.x å’Œå®½åº¦ã€‚ 

```swift 
// ç»˜åˆ¶â¤ï¸å½¢ æ–‡æœ¬ 
override func lineFragmentRect(forProposedRect proposedRect: CGRect,
                               at characterIndex: Int,
                               writingDirection baseWritingDirection: NSWritingDirection,
                               remaining remainingRect: UnsafeMutablePointer<CGRect>?) -> CGRect {
    let rect = super.lineFragmentRect(forProposedRect: proposedRect,
                                      at: characterIndex,
                                      writingDirection: baseWritingDirection,
                                      remaining: remainingRect)
    let containerWidth = Float(size.width), containerHeight = Float(size.height)

    let diameter = fminf(containerWidth, containerHeight)
    let radius = diameter / 2.0
    
    // Vertical distance from the line center to the container center.
    let yDistance = fabsf(Float(rect.origin.y + rect.size.height / 2.0) - radius)
    // The new line width.
    let width = (yDistance < radius) ? 2.0 * sqrt(radius * radius - yDistance * yDistance) : 0.0
    // Horizontal distance from rect.origin.x to the starting point of the line.
    let xOffset = (containerWidth > diameter) ? (containerWidth - diameter) / 2.0 : 0.0
    // The starting x of the line.
    let xPosition = CGFloat(xOffset + Float(rect.origin.x) + radius - width / 2.0)
    return CGRect(x: xPosition, y: CGFloat(rect.origin.y), width: CGFloat(width), height: rect.size.height)
}



```




### è®¾ç½®å¡«å……èƒŒæ™¯è‰²åŠåœ†è§’ 

```swift 

override func fillBackgroundRectArray(rectArray: UnsafePointer, count rectCount: Int, forCharacterRange charRange: NSRange, color: UIColor) { let cornerRadius: CGFloat = 2.0 let path = CGPathCreateMutable() if rectCount == 1 || (rectCount == 2 && CGRectGetMaxX(rectArray[1]) < CGRectGetMinX(rectArray[0])) { CGPathAddRect(path, nil, fixHighlightRect(CGRectInset(rectArray[0], cornerRadius, cornerRadius))) if rectCount == 2 { CGPathAddRect(path, nil, fixHighlightRect(CGRectInset(rectArray[1], cornerRadius, cornerRadius)))
            }
        } else { let lastRect = rectCount - 1 CGPathMoveToPoint(path, nil, CGRectGetMinX(rectArray[0]) + cornerRadius, CGRectGetMaxY(rectArray[0]) + cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMinX(rectArray[0]) + cornerRadius, CGRectGetMinY(rectArray[0]) + cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMaxX(rectArray[0]) - cornerRadius, CGRectGetMinY(rectArray[0]) + cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMaxX(rectArray[0]) - cornerRadius, CGRectGetMinY(rectArray[lastRect]) - cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMaxX(rectArray[lastRect]) - cornerRadius, CGRectGetMinY(rectArray[lastRect]) - cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMaxX(rectArray[lastRect]) - cornerRadius, CGRectGetMaxY(rectArray[lastRect]) - cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMinX(rectArray[lastRect]) + cornerRadius, CGRectGetMaxY(rectArray[lastRect]) - cornerRadius); CGPathAddLineToPoint(path, nil, CGRectGetMinX(rectArray[lastRect]) + cornerRadius, CGRectGetMaxY(rectArray[0]) + cornerRadius); CGPathCloseSubpath(path);

        }

        color.setFill() let context = UIGraphicsGetCurrentContext() CGContextSetLineWidth(context, CGFloat(cornerRadius * 2.0)) CGContextAddPath(context, path) CGContextDrawPath(context, CGPathDrawingMode.FillStroke)
    }

    private func fixHighlightRect(rect: CGRect) -> CGRect { var fixedRect = rect let fixOffset: CGFloat = 6.0 fixedRect.size.height -= fixOffset;
        fixedRect.origin.y += fixOffset; return rect;
    }


```



## è·å–å½“å‰æ›´æ”¹è¡Œ range 
__æ ¹æ®æ›´æ”¹å­—ç¬¦ range è·å–è¡Œ range__ 

```swift

    func processEditing() {
        performReplacementsForRange(changedRange : self.editedRange)
        super.processEditing()
    }

  func performReplacementsForRange(changedRange: NSRange) {
      // è¿™é‡Œæ˜¯ä¸æ˜¯åº”è¯¥æ˜¯æ‹¼æ¥ï¼Ÿ ç®—å‡º location æ‰€åœ¨è¡Œï¼Œå†ç®—å‡º NSMaxRange æ‰€åœ¨è¡Œ(å°±æ˜¯ location + lenght)
      // ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åä¸€ä¸ªå­—ç¬¦æ‰€åœ¨è¡Œï¼Œç„¶åæ‹¼æˆä¸€ä¸ªå¤§çš„ range ï¼Ÿ
      // ç›®å‰è¿™é‡Œæ˜¯æ²¡æœ‰æ‹¼ğŸ‰ï¸ 
      // è¿™é‡Œçš„ line å°±æ˜¯æ ¹æ®æ¢è¡Œç¬¦æ¥è¿›è¡ŒåŒºåˆ†çš„ 
    var extendedRange = NSUnionRange(changedRange, NSString(string: backingStore.string).lineRange(for: NSMakeRange(changedRange.location, 0)))
    extendedRange = NSUnionRange(changedRange, NSString(string: backingStore.string).lineRange(for: NSMakeRange(NSMaxRange(changedRange), 0)))
    // åº”ç”¨ range æ·»åŠ æ–°çš„æ ·å¼
    applyStylesToRange(searchRange: extendedRange)
  }


```


## æ‰¾åˆ°å’Œé«˜äº®ç‚¹å‡»çš„æ–‡å­—  

1. æ‰¾åˆ°ç‚¹å‡»çš„UITextView 
2. è½¬æ¢åæ ‡ï¼Œ å¹¶å‡å»text container çš„è¾¹è·  
3. è·å–ç‚¹å‡»çš„å­—å½¢ç´¢å¼•ï¼ŒæŠŠå­—å½¢ç´¢å¼•è½¬ä¸ºå­—ç¬¦ç´¢å¼•ã€‚ 
4. æ£€æŸ¥é€‰ä¸­çš„å­—ç¬¦æ˜¯å¦æ˜¯ä¸€ä¸ªletterã€‚ 
5. æŠŠå­—ç¬¦çš„ç´¢å¼•æ‰©å±•åˆ°ä¸€ä¸ªwordçš„èŒƒå›´ 
6. åº”ç”¨coloræ•°å­¦

```objective-C
-(void)handleTap:(UITapGestureRecognizer*)tapRecognizer {
    NSTextStorage *textStorage = _layoutManager.textStorage;
    // 1
    CGPoint tappedLocation = [tapRecognizer locationInView:self];
    UITextView *tappedTextView = nil;
    for (UITextView *textView in [self textSubViews]) {
        if (CGRectContainsPoint(textView.frame, tappedLocation)) {
            tappedTextView = textView;
            break; }
    }
    if (!tappedTextView)
        return;
    // 2
    CGPoint subViewLocation = [tapRecognizer locationInView:tappedTextView];
    subViewLocation.y -= 8.0;
    // 3
    NSUInteger glyphIndex = [_layoutManager glyphIndexForPoint:subViewLocation inTextContainer:tappedTextView.textContainer];
    NSUInteger charIndex = [_layoutManager characterIndexForGlyphAtIndex:glyphIndex];
    // 4
    if (![[NSCharacterSet letterCharacterSet] characterIsMember:[textStorage.string characterAtIndex:charIndex]])
        return;
    // 5
    _wordCharacterRange = [self wordThatContainsCharacter:charIndex string:textStorage.string];
    // 6
    [textStorage addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:_wordCharacterRange];
}

- (NSRange)wordThatContainsCharacter:(NSUInteger)charIndex string:(NSString *)string
{
    NSUInteger startLocation = charIndex;
    while(startLocation > 0 &&[[NSCharacterSet letterCharacterSet] characterIsMember: [string characterAtIndex:startLocation-1]]) {
        startLocation--;
    }
    NSUInteger endLocation = charIndex;
    while(endLocation < string.length &&[[NSCharacterSet letterCharacterSet] characterIsMember: [string characterAtIndex:endLocation+1]]) {
        endLocation++;
    }
    return NSMakeRange(startLocation, endLocation-startLocation+1);
}
```


## æ›´æ–°æ ·å¼ 
```swift 

  override public func processEditing() {
        let backingString = backingStore.string
        // è·å–ç¼–è¾‘ range
        if let nsRange = backingString.range(from: NSMakeRange(NSMaxRange(editedRange), 0)) {
            // è·å–line range
            let indexRange = backingString.lineRange(for: nsRange)
            // åˆå¹¶ä¸¤ä¸ª range å¾—åˆ°æœ€å¤§çš„ range
            let extendedRange: NSRange = NSUnionRange(editedRange, backingString.nsRange(from: indexRange))
            // æ­£åˆ™åŒ¹é…æ ·å¼
            applyStyles(extendedRange)
        }
        super.processEditing()
    }


```