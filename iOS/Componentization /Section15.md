# iOS 组件二进制化

### 完成状态
  
- [x] 编写中
- [ ] 已完成
- [ ] 维护中

## 概念简介  
###组件化    
在iOS开发中，随着业务量的不断增大，采用传统的单一工程来实现时会遇到一些问题，比如： 多人协作时不方便，冲突量增大；代码量增多，编译速度变慢； 功能模块较多，模块之间依赖关系复杂等问题。此种问题很大程度上拖慢了项目进度，无形中增加了很多不必要的时间和精力浪费。采用组件化的方式，通过针对不同的业务线进行代码抽离，单独出来成为一个功能集中的单一组件，单独管理；针对基础代码抽离，实现多项目复用。组件化是多项目，多业务开发中的一大趋势，能很好的解决一些不必要的问题   


### 组件二进制化  
iOS 实现组件化的方式一般采用 `CocoaPods` 管理组件化开发， 每一个组件都将是一个单独的 `Pod lib` 库 。虽然 CocoaPods 在一定程度上实现了组件化开发，但由于其具体实现原理是通过一个 `Podfile` 文件去查找到当前库所在的代码管理仓库，例如: `gitlab/github`等，将代码进行clone，链接到项目中，其需要在运行期间针对代码进行打包编译操作，项目编译速度并没有提升，反而可能会有所降低。为了解决此种方式，就有了`组件静态化`。 简单来说， __组件二进制化就是将当前非开发中组件进行打包 编译出静态文件， 在项目引用时直接引用静态文件，将组件的编译过程进行提前，从而降低了组件APP 或者上层组件编译时间，提升编译速度。__   


在讨论具体的二进制化解决方案之前，需要明确一个前提： 当前我们采用的组件化是通过何种形式实现的， 这里默认采用的是 `Cocoapods` 方式来实现   


## 解决方案探索   
二进制化的过程并不是一帆风顺的，其中需要考虑的地方很多。主要包含以下几个方面：  
1. 二进制化过程中不能影响未接入二进制化方案的业务团队  
2. 项目开发中通常会引入一些开源库， 是否需要对此类库进行二进制化？     
3. 组件需要提供针对二进制化和源码的切换功能    
4. 无二进制化版本时如何操作？   
5. 不增加额外工作量   

以上是二进制化过程中几个主要需要考虑的问题， 接下来将围绕这几个问题探讨如何进行二进制化    

通过调研发现，在iOS开发中，实现二进制化一般有一下三种方式： 

###1. cocoapods Package  
`Cocoapods Package` 是一个 Cocoapods 的第三方插件，通过此插件，可以将 pod组件编译成二进制库文件。通过podspec文件动态生成 Podfile 文件，然后 install 出目标工程，最后通过滴啊用系统命令`xcodebuild`构建二进制包。不过目前此库处于不维护状态，其中部分很早的 `issue`都没处理，并且此工具针对swift支持导致无法进行打包操作   

######## 使用方式  
`pod package XXXXXX.podspec --exclude-deps --force --no-mangle --spec-sources=http://git.xxxxx.net/ios/cocoapods-spec.git`

##### 优点：
1. 基于cocoapods实现，可以完美匹配 pod lib 操作

#####缺点： 
1. swift支持不好  
2. 处于不维护状态，存在bug

#### 结论： 
暂且放弃使用此种方式实现，如果需要此种方式实现，需要掌握 Ruby 语言针对此库进行bug修复(目前无法熟练使用Ruby,无法针对此库进行修复，遂放弃)


###2. Carthage  
`Carthage` 是随着swift出来的一个新的开源的依赖库管理工具，通过将第三方依赖编译成二进制文件，然后手动引入项目中。以提前项目构建期针对第三方库的编译工作。并且此库的使用方式也非常简单
通过目标工程文件夹下执行 `carthage build --platform iOS --no-skip-current` 就可以打包出二进制文件  


#####优点 ：
1. 直接针对当前库打包出二进制文件   

#####缺点： 
1. 需要更改`scheme`, 将需要打包的 `Scheme`设置为`Shared`模式
2. 与Cocoapods 是两个不同的工具，增加了学习成本  

#### 结论:
暂且放弃

###3. 原生Xcode 打包   
Xcode 原生支持二进制库的构建实现。通过此种方式实现的话需要针对当前组件工程创建对应的 静态化`Target`，此种方式操作更加繁琐，需要针对文件目录进行一些操作。  

##### 优点： 
1. 原生，不需要任何工具支持  

#####缺点：
1. 操作繁琐，需要针对当前Pod 创建工程进行修改，添加对应的`Target`  

#### 结论： 
不采用  


###结论
通过以上三种针对代码进行二进制化的方式探索中发现，以上三种方式都单独一种方式都不能很好的解决问题，当满足一种需要时必然基友另外一种情况无法满足。针对此种情况如何解决？   既然单一工具无法满足需求，我们是否可以将连个工具解决起来，来完成需求呢?    


### 基于 Cocoapods + Carthage 实现组件二进制化   
通过以上调研发现`Carthage` 可以很好的完成组件的二进制化，然后结合Cocoapods 来实现组件化二进制化。可以通过shell 脚本将两者结合起来，下面具体的给出一种解决方案以供参考   

####1. 环境检测及搭建   
> 注意： 此处只给出 `Carthage` 的安装及检测方式，默认已经安装`Cocoapods`  
```sh
#!/bin/bash
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"  
brew update
brew install Carthage
```

####2. 打包并上传代码  
在具体的介绍打包脚本之前，先来看看基本的pod 库发布流程  

