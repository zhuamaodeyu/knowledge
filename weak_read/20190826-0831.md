
# 第五周  
### 完成状态
  
- [x] 进行中
- [ ] 已完成
- [ ] 维护中

### 日期
#### 2019/08/26-2019/08/31


## 目录 
* [~~SnapKit AutoLayout~~](http://www.hangge.com/blog/cache/detail_1114.html#)
    * [~~iOS Auto Layout Demystified~~](http://jokerhappy.github.io/post/layout%20%E7%AC%94%E8%AE%B02/)

## Knowledge Merge   

### SnapKit AutoLayout  

使用 AutoLayout 实现的View 不能在未开启 AutoLayout 的 window 上使用，可以覆盖`requiresConstraintBasedLayout` 返回 True 以支持  

#### 约束的优先级  
可以通过设置优先级来控制UI 的位置以及大小  

```
box.snp.makeConstraints { (make) -> Void in
        //视图居中
        make.center.equalTo(self.view)
        //初始宽、高为100（优先级低）
        make.width.height.equalTo(100 * self.scacle).priority(250)
        //最大尺寸不能超过屏幕
        make.width.height.lessThanOrEqualTo(self.view.snp.width)
        make.width.height.lessThanOrEqualTo(self.view.snp.height)
    }
self.box.snp.updateConstraints{ (make) -> Void in
        //放大视图（优先级最低）
        make.width.height.equalTo(100 * self.scacle).priority(250)
    }
```
以上代码，实现的是当尺寸最大是屏幕的宽度，因为默认优先级为 1000 ， 而宽度高度更改优先级为 250. 所以当宽度高度为屏幕的宽度时，由于宽度更改优先级较低，所以不会再更改  


#### 兄弟Element 优先级  
此类问题一般出在 根据 text 内容来设置大小的UILabel/UITextView 等控件上  
* Content Hugging Priority   
    表示一个控件抗拉伸的优先级，优先级越高，越不容易被拉伸，默认250  
* Content Compression Resistance Priority  
    表示一个控件的抗压缩优先级，优先级越高，越不容易被压缩。默认是750

```
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

```
> 相关API  

具体实现  

```
[leftLabel setContentCompressionResistancePriority:UILayoutPriorityDefaultLow forAxis:UILayoutConstraintAxisHorizontal];

```


#### 更新 约束  
更新约束有两种方式：  
1. 分开更新约束 
2. 更新block中更新  


##### 更新block中更新  
约束更新需要重写 当前 UI 的 `updateViewConstraints`方法中，并将要更新的约束写在 `super.updateViewConstraints()`前面    

```
    override func updateViewConstraints() {
        self.box.snp.updateConstraints{ (make) -> Void in

        }
         ......
        super.updateViewConstraints()
    }


    //告诉self.view约束需要更新
        self.view.setNeedsUpdateConstraints()
        //动画
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
        }
```


##### 分开更新约束 
通过此种方式将和系统默认给定的约束操作方式一样   

1. 首先保存要更新的那条约束  
```
  box.snp.makeConstraints { (make) -> Void in
            make.width.height.equalTo(150)
            make.centerX.equalTo(self.view)
            // 保存约束
            self.topConstraint = make.top.equalTo(self.view).offset(40).constraint
        }

```
2. 更改约束  
```
 //移除约束
self.sizeConstraint?.deactivate()
 //更新修改约束
self.topConstraint?.update(offset: 60)
```

#### AutoLayout  
##### 布局过程  
1. 约束计算   
    从 `子 ----> 父`, 显式调用`setNeedsUpdateConstraints` 触发此过程，默认更改约束会自动触发此过程。可以覆盖 `updateConstraints`添加和更改约束。 更改约需需要写在 `super` 方法之前    

2. 布局    
    从 `父---->子`,将步骤一的计算结果应用到具体 view frame 上，可以通过显式调用`setNeedsLayout`触发过程，系统会将所有布局请求合并到一个 layout过程中去。 也可以通过调用`layoutIfNeeded`迫使系统立即更新布局。可以覆盖 `layoutSubviews`来hook frame   

3. 展示  
    此过程与autolayout 无关，显示调用 `setNeedsDisplay` 以触发展示，系统会针对绘制过程进行合并  ， 可以通过 `drawRect:`hook 绘制过程


##### Intrinsic Content Size  
固有大小:指一个 view需要正常显示需要的合适 size。例如：多行 UILabel 的 font确定， `preferredMaxLayoutWidth`确定，则它的 `intrinsicContentSize`确定。  
__不是所有的view都有 `intrinsicContentSize`__。 自定义 view 可以通过覆盖 `intrinsicContentSize` 返回合适的size。 可以通过调用 `invalidateIntrinsicContentSize` 通知系统在下一个布局过程中采用新的 Intrinsic Content Size     

##### Alignment Rect  
AutoLayout 操作的是 Alignment Rect, 不是 view的Frame。此内容是为了与 View 的布局和显示解耦。在自定义的View 中， 可以覆盖 `alignmentRectInsets` 来返回特定Frame 下 Alignment Rect的edge insets是多少。 还可以覆盖 `alignmentRectForFrame:`和`frameForAlignmentRect:`来实现更精细的控制   


##### Other  
*  `Edit Scheme` 中添加 `Arguments`启动参数`UIViewShowAlignmentRects = true`，可以运行时显示视图对齐矩阵    
* `NSDoubleLocalizedStrings`  
